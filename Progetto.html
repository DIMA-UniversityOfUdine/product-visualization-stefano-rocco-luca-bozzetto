<html>
	<head>
		<title>Load OBJ File</title>
        <link rel="stylesheet" type="text/css" href="Menu.css">
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/OBJLoader.js"></script>
	</head>
	<body>
        
        <div id="men">        <!--Contenitore menÃ¹-->            
            <ul id="uno">
                <li class="prova">Material  <!--Property that will change-->
                    <ul>
                        <button class="hidden">Mat1</button>  <!--Choices for the property-->
                        <button class="hidden">Mat2</button>
                        <button class="hidden">Mat3</button>
                    </ul>
                </li>
            </ul>
            
            <ul id="due">
                <li class="prova">SecProperty  <!--Property that will change-->
                    <ul>    
                        <button class="hidden">SecProp1</button>  <!--Choices for the property-->
                        <button class="hidden">SecProp2</button>
                        <button class="hidden">SecProp3</button>
                    </ul>
                </li>
            </ul>
        </div>
        
        <a href=""><img src="carrello.gif" alt="Pulsante per acquistare" align= "right";/></a>
         
        
        
        <script type="text/x-glsl" id="vertex">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

		<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space
			uniform vec3 clight;
			uniform vec3 cspec;
			uniform vec3 cdiff;
			uniform float roughness;
			const float PI = 3.14159;

			vec3 FSchlick(float lDoth) {
				return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
			}

			float DGGX(float nDoth, float alpha) {
				float alpha2 = alpha*alpha;
				float d = nDoth*nDoth*(alpha2-1.0)+1.0;
				return (  alpha2 / (PI*d*d));
			}

			float G1(float dotProduct, float k) {
				return (dotProduct / (dotProduct*(1.0-k) + k) );
			}

			float GSmith(float nDotv, float nDotl) {
					float k = roughness*roughness;
					return G1(nDotl,k)*G1(nDotv,k);
			}

			#extension GL_OES_standard_derivatives : enable

		

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);
				vec3 fresnel = FSchlick(lDoth);
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
					(4.0*nDotl*nDotv);
				vec3 outRadiance = PI* clight * nDotl * BRDF;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}
            
            
		</script>
        
        
        
        
        
        
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );
            
            vs = document.getElementById("vertex").textContent;
			fs = document.getElementById("fragment").textContent;
			
        
            var mlib = {
				"Orange": 	new THREE.MeshLambertMaterial( { color: 0xff6600, reflectivity: 0.3 } ),
				"Blue": 	new THREE.MeshLambertMaterial( { color: 0x001133, reflectivity: 0.3 } ),
                "White":	new THREE.MeshLambertMaterial( { color: 0xffffff, reflectivity: 0.25 } ),
            };
			var loader = new THREE.OBJLoader();
            loader.load( "drone.obj", function ( group ) {
                for (var i = 0; i < group.children.length; i++) {
                    var geometry = group.children[i].geometry;
                    var material = mlib [ "Orange" ];
                    mesh = new THREE.Mesh(geometry, material);
                    scene.add(mesh);
                }
            } );
			
            // cubemap
            
            var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'cubemaps/Storforsen2/' ); //cambiare solo il nome dell'ultima cartella per cambiare la cubemap

				var textureCube = loader.load( [
					'posx.jpg', 'negx.jpg',
					'posy.jpg', 'negy.jpg',
					'posz.jpg', 'negz.jpg'
				] );

			scene.background = textureCube;
			textureCube.minFilter = THREE.LinearMipMapLinearFilter;
            
            // camera
            
            
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
            camera.position.set( 10, 5, 50 );
            camera.lookAt(new THREE.Vector3(0,0,0));
            
            scene.add( camera );
            
            // spotlight
            
            var spotLight = new THREE.SpotLight( 0x8fa25, 1 );
            var lightHelper;
            
            spotLight.position.set( 0, 0, 30 );
			spotLight.castShadow = true;
			spotLight.angle = Math.PI / 16;
			spotLight.penumbra = 0;
			spotLight.decay = 1;
			spotLight.distance = 100;
			spotLight.shadow.mapSize.width = 1024;
			spotLight.shadow.mapSize.height = 1024;
			spotLight.shadow.camera.near = 10;
			spotLight.shadow.camera.far = 50;
            
            lightHelper = new THREE.SpotLightHelper( spotLight );
            
            scene.add( spotLight );
            scene.add( lightHelper );
            
            // arealight
            
            var rectLight;
			var rectLightHelper;
            
            rectLight = new THREE.RectAreaLight( 0xFFFFFF, undefined, 2, 10 );
            rectLight.matrixAutoUpdate = true;
            rectLight.intensity = 80.0;            
            rectLightHelper = new THREE.RectAreaLightHelper( rectLight );
            rectLightHelper.position.set( 10, 0, 0 );
            scene.add( rectLightHelper );
            scene.add( rectLight );
            
            //*************************************************************************
            
			function render() {
				requestAnimationFrame(render);
				stats.update();
				
				renderer.render(scene, camera);
			}
			
			render();
		</script>
	</body>
</html>
